# This is the right place to customize your installation of SpamAssassin.
#
# See 'perldoc Mail::SpamAssassin::Conf' for details of what can be
# tweaked.
#
# Only a small subset of options are listed below
#
###########################################################################

#    A 'contact address' users should contact for more info. (replaces
#    _CONTACTADDRESS_ in the report template)
# report_contact youremailaddress@domain.tld


#   Add *****SPAM***** to the Subject header of spam e-mails
#
# rewrite_header Subject *****SPAM*****
{% if spamassassin_rewrite_header_enabled %}
rewrite_header {{ spamassassin_rewrite_header }}
{% endif %}


#   Save spam messages as a message/rfc822 MIME attachment instead of
#   modifying the original message (0: off, 2: use text/plain instead)
#
# report_safe 1
report_safe {{ spamassassin_report_safe }}

##########################################################################
# Headers to be added to mail (can be overriden by users in
# ~/.spamassassin/user_prefs)
# Make sure the header stays entirely on one line here

clear_headers

#X-Spam-ASN: AS24940 213.239.192.0/18
add_header all ASN _ASN_

#X-Spam-Checker-Version: SpamAssassin 1.188-2003-05-24-exp on machine.example.org
add_header all Checker-Version SpamAssassin _VERSION_ on _HOSTNAME_

#X-Spam-Flag: YES
add_header spam Flag _YESNOCAPS_

#X-Spam-Status: Yes, score=14.0 required=5.0 autolearn=spam
add_header all Status "_YESNO_, score=_SCORE_ required=_REQD_ autolearn=_AUTOLEARN_"

# X-Spam-Report: Terse report of tests hit
add_header all Report _REPORT_

#   Set which networks or hosts are considered 'trusted' by your mail
#   server (i.e. not spammers)
#
# trusted_networks 212.17.35.
{% for network in spamassassin_trusted_networks %}
trusted_networks {{ network }}
{% endfor %}

#   Whether DNS resolving is available or isn't
# dns_available yes
dns_available {{ spamassassin_dns_available }}

#   Which DNS servers to use
# dns_server 127.0.0.1
{% if spamassassin_dns_servers %}
{% for dns_server in spamassassin_dns_servers %}
dns_server {{ dns_server }}
{% endfor %}
{% endif %}

#   Set file-locking method (flock is not safe over NFS, but is faster)
#
# lock_method flock
lock_method {{ spamassassin_lock_method }}


#   Set the threshold at which a message is considered spam (default: 5.0)
#
# required_score 5.0
required_score {{ spamassassin_required_score }}

# ASN - Look up the Autonomous System Number of the connecting IP
# and create a header containing ASN data for bayes tokenization.
# https://spamassassin.apache.org/full/4.0.x/doc/Mail_SpamAssassin_Plugin_ASN.html
loadplugin Mail::SpamAssassin::Plugin::ASN
asn_prefer_geodb 1
asn_use_geodb 1
asn_use_dns 0

#   Use Bayesian classifier (default: 1)
#
# use_bayes 1
use_bayes {{ spamassassin_use_bayes }}

bayes_path {{ spamassassin_bayes_path }}/bayes

#   The file mode bits used for the Bayesian filtering database files.
#
#   Make sure you specify this using the 'x' mode bits set, as it may also be
#   used to create directories. However, if a file is created, the resulting file
#   will not have any execute bits set (the umask is set to 111).
#
# bayes_file_mode 0700
bayes_file_mode {{ spamassassin_bayes_file_mode }}

#   Bayesian classifier auto-learning (default: 1)
#
# bayes_auto_learn 1
bayes_auto_learn {{ spamassassin_bayes_auto_learn }}

#   The score threshold below which a mail has to score, to be fed into
#   SpamAssassin's learning systems automatically as a non-spam message.
#
# bayes_auto_learn_threshold_nonspam 0.1
bayes_auto_learn_threshold_nonspam {{ spamassassin_bayes_auto_learn_threshold_nonspam }}

#   The score threshold above which a mail has to score, to be fed into
#   SpamAssassin's learning systems automatically as a spam message.
#
#   Note: SpamAssassin requires at least 3 points from the header, and 3 points
#   from the body to auto-learn as spam. Therefore, the minimum working value for
#   this option is 6.
#
# bayes_auto_learn_threshold_spam 12.0
bayes_auto_learn_threshold_spam {{ spamassassin_bayes_auto_learn_threshold_spam }}

#   With bayes_auto_learn_on_error off, autolearning will be performed even if
#   bayes classifier already agrees with the new classification (i.e. yielded
#   BAYES_00 for what we are now trying to teach it as ham, or yielded BAYES_99
#   for spam). This is a traditional setting, the default was chosen to retain
#   backward compatibility.
#
#   With bayes_auto_learn_on_error turned on, autolearning will be performed
#   only when a bayes classifier had a different opinion from what the
#   autolearner is now trying to teach it (i.e. it made an error in
#   judgement). This strategy may or may not produce better future
#   classifications, but usually works very well, while also preventing
#   unnecessary overlearning and slows down database growth.
#
# bayes_auto_learn_on_error 0

bayes_auto_learn_on_error {{ spamassassin_bayes_auto_learn_on_error }}

#   Controls which sources in a mail message can contribute tokens (e.g. words,
#   phrases, etc.) to a Bayes classifier. The argument is a space-separated list
#   of keywords: header, visible, invisible, uri, mimepart), each of which may be
#   prefixed by a no to indicate its exclusion. Additionally two reserved
#   keywords are allowed: all and none (or: noall). The list of keywords is
#   processed sequentially: a keyword all adds all available keywords to a set
#   being built, a none or noall clears the set, other non-negated keywords are
#   added to the set, and negated keywords are removed from the set. Keywords are
#   case-insensitive.
#
#   The default set is: header visible invisible uri, which is equivalent for
#   example to: All NoMIMEpart. The reason why mimepart is not currently in a
#   default set is that it is a newer source (introduced with SpamAssassin
#   version 3.4.1) and not much experience has yet been gathered regarding its
#   usefulness.
#
#   See also option bayes_ignore_header for a fine-grained control on individual
#   header fields under the umbrella of a more general keyword header here.
#
#   Keywords imply the following data sources:
#
#   header - tokens collected from a message header section
#   visible - words from visible text (plain or HTML) in a message body
#   invisible - hidden/invisible text in HTML parts of a message body
#   uri - URIs collected from a message body
#   mimepart - digests (hashes) of all MIME parts (textual or non-textual) of
#              a message, computed after Base64 and quoted-printable decoding,
#              suffixed by their Content-Type
#   all - adds all the above keywords to the set being assembled
#   none or noall - removes all keywords from the set
#
#   The bayes_token_sources directive may appear multiple times, its keywords are
#   interpreted sequentially, adding or removing items from the final set as they
#   appear in their order in bayes_token_sources directive(s).
#
# bayes_token_sources header visible invisible uri
bayes_token_sources {{ spamassassin_bayes_token_sources | join(' ') }}

#   If you receive mail filtered by upstream mail systems, like a spam-filtering
#   ISP or mailing list, and that service adds new headers (as most of them do),
#   these headers may provide inappropriate cues to the Bayesian classifier,
#   allowing it to take a "short cut". To avoid this, list the headers using this
#   setting. Header matching is case-insensitive. Example:
#
#   bayes_ignore_header X-Bogosity
#   bayes_ignore_header X-Spam-Flag
#   bayes_ignore_header X-Spam-Status
{% for header in spamassassin_bayes_ignore_header %}
bayes_ignore_header {{ header }}
{% endfor %}

#   Bayesian classification and autolearning will not be performed on mail from
#   the listed addresses. Program sa-learn will also ignore the listed addresses
#   if it is invoked using the --use-ignores option. One or more addresses can be
#   listed, see welcomelist_from.
#
#   Spam messages from certain senders may contain many words that frequently
#   occur in ham. For example, one might read messages from a preferred
#   bookstore but also get unwanted spam messages from other bookstores. If
#   the unwanted messages are learned as spam then any messages discussing
#   books, including the preferred bookstore and antiquarian messages would be
#   in danger of being marked as spam. The addresses of the annoying
#   bookstores would be listed. (Assuming they were halfway legitimate and
#   didn't send you mail through myriad affiliates.)
#
#   Those who have pieces of spam in legitimate messages or otherwise receive ham
#   messages containing potentially spammy words might fear that some spam
#   messages might be in danger of being marked as ham. The addresses of the spam
#   mailing lists, correspondents, etc. would be listed.
#
# bayes_ignore_from user@example.com
{% if spamassassin_bayes_ignore_from %}
bayes_ignore_from {{ spamassassin_bayes_ignore_from | join(' ') }}
{% endif %}

#   Bayesian classification and autolearning will not be performed on mail to the
#   listed addresses. See bayes_ignore_from for details.
#
# bayes_ignore_to user@example.com
{% if spamassassin_bayes_ignore_to %}
bayes_ignore_to {{ spamassassin_bayes_ignore_to | join(' ') }}
{% endif %}

#   The Bayes system will, by default, learn any reported messages
#   (spamassassin -r) as spam. If you do not want this to happen, set this option
#   to 0.
#
# bayes_learn_during_report 1
bayes_learn_during_report {{ spamassassin_bayes_learn_during_report }}

#   What should be the maximum size of the Bayes tokens database? When expiry
#   occurs, the Bayes system will keep either 75% of the maximum value, or
#   100,000 tokens, whichever has a larger value. 150,000 tokens is roughly
#   equivalent to a 8Mb database file.
#
# bayes_expiry_max_db_size 150000
bayes_expiry_max_db_size {{ spamassassin_bayes_expiry_max_db_size }}

#   If enabled, the Bayes system will try to automatically expire old tokens from
#   the database. Auto-expiry occurs when the number of tokens in the database
#   surpasses the bayes_expiry_max_db_size value. If a bayes datastore backend
#   does not implement individual key/value expirations, the setting is silently
#   ignored.
#
# bayes_auto_expire 1
bayes_auto_expire {{ spamassassin_bayes_auto_expire }}

#   Time-to-live / expiration time in seconds for tokens kept in a Bayes
#   database. A numeric value is optionally suffixed by a time unit
#   (s, m, h, d, w, indicating seconds (default), minutes, hours, days, weeks).
#
#   If bayes_auto_expire is true and a Bayes datastore backend supports it
#   (currently only Redis), this setting controls deletion of expired tokens from
#   a bayes database. The value is observed on a best-effort basis, exact timing
#   promises are not necessarily kept. If a bayes datastore backend does not
#   implement individual key/value expirations, the setting is silently ignored.
#
# bayes_token_ttl 3w
bayes_token_ttl {{ spamassassin_bayes_token_ttl }}

#   Time-to-live / expiration time in seconds for 'seen' entries (i.e. mail
#   message digests with their status) kept in a Bayes database. A numeric value
#   is optionally suffixed by a time unit (s, m, h, d, w, indicating seconds
#   (default), minutes, hours, days, weeks).
#
#   If bayes_auto_expire is true and a Bayes datastore backend supports it
#   (currently only Redis), this setting controls deletion of expired 'seen'
#   entries from a bayes database. The value is observed on a best-effort basis,
#   exact timing promises are not necessarily kept. If a bayes datastore backend
#   does not implement individual key/value expirations, the setting is silently
#   ignored.
#
# bayes_seen_ttl 8d
bayes_seen_ttl {{ spamassassin_bayes_seen_ttl }}

#   If this option is set, whenever SpamAssassin does Bayes learning, it will put
#   the information into the journal instead of directly into the database. This
#   lowers contention for locking the database to execute an update, but will
#   also cause more access to the journal and cause a delay before the updates
#   are actually committed to the Bayes database.
#
# bayes_learn_to_journal 0
bayes_learn_to_journal {{ spamassassin_bayes_learn_to_journal }}

#   Whether to decode non- UTF-8 and non-ASCII textual parts and recode
#   them to UTF-8 before the text is given over to rules processing.
#
# normalize_charset 1

#   Textual body scan limit    (default: 50000)
#
#   Amount of data per email text/* mimepart, that will be run through body
#   rules.  This enables safer and faster scanning of large messages,
#   perhaps having very large textual attachments.  There should be no need
#   to change this well tested default.
#
# body_part_scan_size 50000

#   Textual rawbody data scan limit    (default: 500000)
#
#   Amount of data per email text/* mimepart, that will be run through
#   rawbody rules.
#
# rawbody_part_scan_size 500000

#   All DNS queries are made at the beginning of a check and we try to read the
#   results at the end. This value specifies the maximum period of time (in
#   seconds) to wait for a DNS query. If most of the DNS queries have succeeded
#   for a particular message, then SpamAssassin will not wait for the full period
#   to avoid wasting time on unresponsive server(s), but will shrink the timeout
#   according to a percentage of queries already completed. As the number of
#   queries remaining approaches 0, the timeout value will gradually approach a
#   t_min value, which is an optional second parameter and defaults to 0.2 * t.
#   If t is smaller than t_min, the initial timeout is set to t_min. Here is a
#   chart of queries remaining versus the timeout in seconds, for the default 15
#   second / 3 second timeout setting:
#
#   queries left  100%  90%  80%  70%  60%  50%  40%  30%  20%  10%   0%
#   timeout        15   14.9 14.5 13.9 13.1 12.0 10.7  9.1  7.3  5.3  3
#
#   For example, if 20 queries are made at the beginning of a message check
#   and 16 queries have returned (leaving 20%), the remaining 4 queries should
#   finish within 7.3 seconds since their query started or they will be timed
#   out. Note that timed out queries are only aborted when there is nothing
#   else left for SpamAssassin to do - long evaluation of other rules may
#   grant queries additional time.
#
#   If a parameter 'zone' is specified (it must end with a letter, which
#   distinguishes it from other numeric parametrs), then the setting only
#   applies to DNS queries against the specified DNS domain (host, domain or
#   RBL (sub)zone). Matching is case-insensitive, the actual domain may be a
#   subdomain of the specified zone.
#
# rbl_timeout t [t_min] [zone] (default: 15 3)

rbl_timeout 25 5

#   Some shortcircuiting, if the plugin is enabled
#
ifplugin Mail::SpamAssassin::Plugin::Shortcircuit
#
#   default: strongly-welcomelisted mails are *really* welcomelisted now, if the
#   shortcircuiting plugin is active, causing early exit to save CPU load.
#   Uncomment to turn this on
#
#   SpamAssassin tries hard not to launch DNS queries before priority -100.
#   If you want to shortcircuit without launching unneeded queries, make
#   sure such rule priority is below -100. These examples are already:
#
# shortcircuit USER_IN_WELCOMELIST       on
# shortcircuit USER_IN_DEF_WELCOMELIST   on
# shortcircuit USER_IN_ALL_SPAM_TO     on

#   the opposite; blocklisted mails can also save CPU
#
# shortcircuit USER_IN_BLOCKLIST       on
# shortcircuit USER_IN_BLOCKLIST_TO    on

#   if you have taken the time to correctly specify your "trusted_networks",
#   this is another good way to save CPU
#
# shortcircuit ALL_TRUSTED             on

#   and a well-trained bayes DB can save running rules, too
#
# shortcircuit BAYES_99                spam
# shortcircuit BAYES_00                ham

endif # Mail::SpamAssassin::Plugin::Shortcircuit

# Pyzor Config Section
{% if spamassassin_pyzor_enabled %}
use_pyzor 1
{% else %}
use_pyzor 0
{% endif %}
pyzor_options --homedir {{ spamassassin_pyzor_config_dir }}

# Razor Config Section
{% if spamassassin_razor_enabled %}
use_razor2 1
{% else %}
use_razor2 0
{% endif %}
razor_config {{ spamassassin_razor_config_dir }}

{% if spamassassin_custom_rules %}
# custom rules
{% for rule in spamassassin_custom_rules %}
{{ rule }}
{% endfor %}
{% endif -%}

{% if spamassassin_custom_scores %}
# custom scores
{% for score in spamassassin_custom_scores %}
score {{ score.name }} {{ score.score }}
{% endfor %}
{% endif %}

# additional config files
include welcomelist.cf
